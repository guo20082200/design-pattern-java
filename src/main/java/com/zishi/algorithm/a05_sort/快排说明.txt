参考： https://blog.csdn.net/weixin_45031801/article/details/126962679


1.问题分析
    快速排序是比较快的排序方法。它的基本思想是通过一组排序将要排序的数据分割成独立的两部分，
    其中一部分的所有数据都比另外一部分的所有数据小，然后再按此方法对这两部分数据进行快速排序，
    整个排序过程可以递归进行，以此使所有数据变成有序序列。

2.算法设计
    2.1 分解：
        先从数列中取出一个元素作为基准元素。一基准元素为标准，将问题分解为两个子序列，
        使小于或者等于基准元素的子序列在左侧，使大于基准元素的子序列在右侧。
    2.2 治理 ：
        对两个子序列进行快速排序（递归快速排序）。
    2.3 合并：
        将排好的两个子序列合并在一起，得到原问题的解。
    2.4 基准元素的选取：
        a. 取第一个元素。(通常选取第一个元素)
        b. 取最后一个元素
        c. 取中间位置的元素
        d. 取第一个、最后一个、中间位置元素三者之中位数
        e. 取第一个和最后一个之间位置的随机数 k (low<=k<=hight)

3.算法分析
    假设当前的待排序的序列为 R[low,hight] ， 其中 low<=hight。同时选取首元素为基准元素。
    步骤一：选取首元素的第一个元素作为基准元素  pivot=R[low] ，i=low ，j=hight。
    步骤二：从右向左扫描，找到小于等于 pivot 的数，如果找到，R[i] 和 R[j] 交换 ，i++。
    步骤三：从左向右扫描，找到大于 pivot 的数，如果找到，R[i] 和 R[j] 交换，j--。
    步骤四：重复 步骤二~步骤三，直到  j 与 i 的指针重合 返回位置 mid=i ，该位置的数正好是 pivot 元素。
    至此换成一趟排序，此时以 mid 为界线，将数据分割为两个子序列，左侧子序列都比 pivot 数小，右侧子序列都比 pivot 数大，然后再分别对这两个子序列进行快速排序。


4. 下面我将以序列（30，24，5，58，18，36，12，42，39）为例，进行图解。
    4.1 初始化。i=low ，j=height，pivot=R[low]=30。(这里low =0， height = arr.length - 1)
        数组的结果为： (30，24，5，58，18，36，12，42，39)
    4.2 向左走，从数组的右边位置向左找，一直找到小于等于 pivot 的数，找到R[j]=12，R[i]与R[j]交换，i++。
        数组的结果为： (12，24，5，58，18，36，30，42，39)
    4.3 向右走，从数组的左边位置向右找，一直找到比 pivot 大的数，找到 R[i]=58 ,R[i] 与 R[j] 交换 ，j--。
        数组的结果为： (12，24，5，30，18，36，58，42，39)
    4.4 向左走，从数组的右边位置向左找，一直找到小于等于 pivot 的数，找到R[j]=18，R[i]与R[j]交换，i++。
        数组的结果为： (12，24，5，18，30，36，58，42，39)
    4.5 向右走，从数组的左边位置向右找，一直找到比 pivot 大的数，这是 i=j，第一轮排序结束，返回 i 的位置，mid=i
        数组的结果为： (12，24，5，18，30，36，58，42，39)

    4.6 然后在分别对这两个序列（12，24，5，18）和（36，58，42，39）进行快速排序（递归）












