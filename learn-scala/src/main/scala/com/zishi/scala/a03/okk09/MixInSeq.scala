package com.zishi.scala.a03.okk09


/**
 * 特质的构造顺序最重要的!!
 * 特质也是有构造器的，构造器中的内容由“字段的初始化”和一些其他语句构成。具体实现请参考“特质叠加”
 *
 * 1. 第一种特质构造顺序(声明类的同时混入特质)
 *  调用当前类的超类构造器
 *  第一个特质的父特质构造器
 *  第一个特质构造器
 *  第二个特质构造器的父特质构造器, 如果已经执行过，就不再执行
 *  第二个特质构造器
 *  …重复 4,5 的步骤(如果有第 3 个，第 4 个特质)
 *
 *
 * 2. 第二种特质构造顺序(在构建对象时, 动态混入特质)
 *
 *  调用当前类的超类构造器
 *  当前类构造器
 *  第一个特质构造器的父特质构造器
 *  第一个特质构造器.
 *  第二个特质构造器的父特质构造器, 如果已经执行过，就不再执行
 *  第二个特质构造器
 *  …重复 5,6 的步骤(如果有第 3 个，第 4 个特质)
 *
 * 3. 当前类构造器
 *  分析两种方式对构造顺序的影响
 *  第 1 种方式实际是构建类对象, 在混入特质时，该对象还没有创建。
 *  第 2 种方式实际是构造匿名子类，可以理解成先创建了该对象, 再混入特质
 */
object MixInSeq {
  def main(args: Array[String]): Unit = {
    //这时 FF 是这样 形式 class FF extends EE with CC with DD
    /*
    调用当前类的超类构造器
    第一个特质的父特质构造器
    第一个特质构造器
    第二个特质构造器的父特质构造器, 如果已经执行过， 就不再执行
    第二个特质构造器
    .......重复 4,5 的步骤(如果有第 3 个，第 4 个特质) 当前类构造器 [案例演示]
    */
    //1. E...
    //2. A...
    //3. B....
    //4. C....
    //5. D....
    //6. F....
    val ff1 = new FF()
    println(ff1)
    //这时我们是动态混入
    /*
    先创建 new KK 对象，然后再混入其它特质
      调用当前类的超类构造器
    当前类构造器
    第一个特质构造器的父特质构造器
    第一个特质构造器.
    第二个特质构造器的父特质构造器, 如果已经执行过，就不再执行 第二个特质构造器
    .......重复 5,6 的步骤(如果有第 3 个，第 4 个特质)
    当前类构造器
    */
    //1. E...
    //2. K....
    //3. A...
    //4. B
    //5. C
    //6. D
    println("=======================")
    val ff2 = new KK with CC with DD
    println(ff2)
  }
}

trait AA {
  println("A...")
}

trait BB extends AA {
  println("B....")

}

trait CC extends BB {
  println("C....")
}

trait DD extends BB {
  println("D....")
}

class EE { //普通类
  println("E...")
}

class FF extends EE with CC with DD { //先继承了 EE 类，然后再继承 CC 和 DD
  println("F....")
}

class KK extends EE { //KK 直接继承了普通类 EE
  println("K....")
}
